viewport:width=device-width,initial-scale=1

目录

[TOC]

##sort排序
###概述
**排序确切的定义**
$含有n个记录的序列为\\{R_1,R_2,\cdots,R_n\\}\\\
其相应的关键字序列为\\{K_1,K_2,\cdots,K_n\\},\\\
需确定1,2,\cdots,n的一种排列为p_1,p_2,\cdots,p_n,使其相应的关键字满足非递减或非递增关系\\\
\quad\quad\quad K_{p_1}\leqslant K_{p_2}\leqslant \cdots K_{p_n}\\\
使序列称为一个按关键字有序的序列\\\
\quad\quad\quad \\{R_{p_1}, R_{p_2}, \cdots R_{p_n}\\}
如果K_i是主关键字,因其不允许重复,得到的排序结果是唯一的\\\$
如果K_i是次关键字,有可能存在两个或两个以上关键字相等,排序序列不唯一,
相应的排序方法就有<u>稳定与不稳定之分</u>

**内排序与外排序**

+ 内排序:记录一次读入内存
+ 外排序:记录过多无法一次读入内存,,??在排序过程中尚需对外存进行访问

**内排序方法分类**

+ 依据**<u>不同原则</u>**分类
	- 插入排序
	- 交换排序
	- 选择排序
	- 归并排序
	- 计数排序
+ 依据排序所需工作量分类
	- 简单排序方法,$O(n^2)$
	- 先进排序方法,$O(nlogn)$
	- 基数排序,$O(d\cdot n)$

**排序过程中的基本操作**

+ *比较*关键字大小
+ 将记录从一个位置*移动*至另一个位置
	- 通过改变记录存储方式避免
		+ 顺序存储
		+ 静态链表
		+ 顺序存储+地址向量
+ 讨论算法复杂度时,也就会分别讨论比较次数和移动次数		
###插入排序
####直接插入排序
思想
>将一个记录插入到已排好序的有序表中;
将序列中的第1个记录看出是一个有序的子序列,从第2个记录起逐个进行插入

#####**效率分析**

+ 空间复杂度:一个记录的辅助空间
+ 时间复杂度:
	- 最好情况:记录已经`正序`$O(n)$
		+ 比较次数:$\sum\limits_{i=2}^{n}1=n-1$
			- $a[i]只需要和a[i-1]比较一次进行了$
		+ 移动次数:不需要移动$0$
	- 最坏情况:记录`逆序`
		+ 比较次数:$\sum\limits_{i=2}^{n}i=\frac{(n-2)(n-1)}{2}$
			- $a[i]要一直比较到a[0],从a[0]到a[i-1]比较了i次$
		+ 移动次数:$\sum\limits_{i=2}^{n}i+1=\frac{(n+4)(n-1)}{2}$
			- $a[i]赋给a[0];a[1]-a[i-1]后移赋值;a[i]的值赋给a[1],\\\赋值操作共计i+1次$
	- <u>若待排序记录是随机的,即记录可能出现的各种排列概率相同,可以取最大值和最小值的平均值</u>$n^2/4$
	- 直接插入排序时间复杂度$O(n^2)$
####其他插入排序
#####折半插入排序
>用折半查找得到记录插入的位置,减少比较的次数,记录移动的次数不变

时间复杂度$O(n^2)$
#####2-路插入排序
需要n个记录的辅助空间作为一个循环向量
用first和final指针分别指向有序序列的收尾位置,(而不是按数组下标有序)
<u>来减少记录移动的次数</u>

当原始记录第一个键值是最值时,循环向量起不了作用,算法也无法减少记录移动次数
#####表插入排序
<u>通过使用静态链表来减少记录移动的次数</u>
??重排记录的做法,,?
####希尔排序,缩小增量排序
>:将整个待排记录(按增量)分割为若干个子序列分别进行直接插入排序
带整个序列中的记录'基本有序'时,对对全体记录进行一次直接插入排序
利用了基本有序时插入排序时间复杂度提高到O(n)的特性

```c
ShellSort()
{
	// 增量序列,例如:9,5,3,...递减,也就是缩小增量序列
	dlta[0...t-1]
	for(k = 0; k < t; ++k)
	{
		/**
		**按dlta[k]的取值,对待排序序列按dlta[k]的间隔分成多个子序列
		**对各个子序列进行插入排序
		**子序列插入排序时,前后记录位置每次变化dlta[k],而不是1
		**/
		ShellInsert(L,dlta[k])
	}
}
```
###交换排序
借助`交换`排序
####冒泡排序
>比较相邻记录(的关键字),逆序时交换相邻记录,
每一趟排序使得关键字最大的记录被交换到 本趟范围内的最后一个位置
结束条件:在一趟排序过程中没有进行过交换记录的操作

#####**效率分析**

+ 时间复杂度分析
	- 最好情况:记录已经`正序`,只需$1$趟排序
	一趟排序中
		+ 比较$n-1次关键字,$
		+ $不移动记录$
	- 最坏情况:记录是`逆序`的,需要$n-1趟排序$
	在每趟排序中
		+ 比较$i-1次$,共计比较$\sum\limits_{i=n}^{2}(i-1)=n(n-1)/2次$
		+ 移动/交换$i-1次$,共计交换$\sum\limits_{i=n}^{2}(i-1)=n(n-1)/2次$
		
####快速排序
```c
void QuickSort(L)
{
	/**QSort递归调用
	**最终有序
	**/
	QSort(L,1(low),L.length(high))
				
		if(low < high)
		{			
					/**Partition:一趟快速排序
					**以L[low]为轴将L一份为二
					**得到一个pivot(轴)的位置(location)
					**使得轴左边的记录 < 轴 < 轴右边的记录
					**/
			PivotLoc=Partition(L,low,high)
			QSort(L,low,PivotLoc-1)
			QSort(L,PivotLoc+1,high)	
		}
}
```
#####**效率分析**
<u>就平均时间而言,快速排序目前被认为是最好的一种内部排序方法</u>

+ 时间复杂度分析
	- $T(n)为对n个记录进行快速排序所需时间,\\\
	T_{pass}(n)为对n个记录进行一趟快速排序所需时间\\\
	T(n)=T_{pass}(n)+T(k-1)+T(n-k),(PivotLoc=k)$
	- $T_{pass}(n)=cn,因为Partition是从表的两端交替地向中间扫描\\\
	只需遍历表一遍就可完成操作,时间复杂度O(n)=cn,c为某个常数$
	- $快速排序所需平均时间\\\
	记录随机排序,则一趟排序后,k去1-n之间任何一值概率相同\\\
	T_{avg}(n)=cn+ \frac{1}{n}\sum\limits_{k=1}^{n}[T_{avg}(k-1)+T_{avg}(n-k)]\\\
	=\cdots\\\
	< \cdots\\\
	=O(nlogn)$
	- 若初始记录序列按关键字有序或基本有序(比如逆序)的时候,
	枢轴的值往往是最值,每次partition后序列长度减一/(枢轴两边的序列长度不均匀,,)
	快速排序就蜕化为了冒泡排序
		+ 为解决这个问题<u>用三者取中</u>的法则来避免枢轴取成最值
		即取$L[s],L[\frac{s+t}{2}],L[t]三者关键字的中值为枢轴$
		来改善快速排序在最坏情况下的性能
	- 修改`一次划分`,
	在partition的同时进行冒泡操作,
	进一步改善性能
+ 空间复杂度
	- 栈空间深度
###选择排序:找无序序列中的最小值/找第i小的值
基本思想
>每一趟在a[i],a[i+1]...a[n]这n-i+1个记录中选择关键字最小的记录
作为这个子序列的第一个记录也就是有序序列的第i个记录
####简单选择排序
基本思想
$第i趟简单选择排序在a[i]...a[n]这n-i+1个记录中作n-i次比较,\\\
(a[i]和\\{a[i+1],\cdots,a[n]\\}比,共计比n-i次)\\\
选择出关键字最小的记录,也就是整个序列中第i小的记录,和a[i]交换\\\
总计需要n-1趟\\\
第1趟让a[1]和\\{a[2],\cdots,a[n]\\}比较\\\
\vdots\\\
第n-1趟,比较a[n-1]和a[n]$

```c
void SelectSort(L)
{
	for(i = 1;i< L.length;++i)
	{
		j = SelectMinKey(L,i);
		if(i != j) L[i]<->L[j];
	}
}
```
#####**效率分析**
+ 时间复杂度
	- 最好情况:序列已经`正序`
		+ 移动次数:每一趟都不需要交换记录,$0$
		+ 比较次数:每一趟比较$n-i次\\\
		共计比较\sum\limits_{i=1}^{n-1}n-i=n(n-1)/2$
	- 最坏情况:序列`逆序`
		+ 移动次数:每一趟都要交换,交换两个记录需要三次赋值,共计交换/移动$3(n-1)$
		+ 比较次数:和最好情况下相同

>在n个关键字中选出最小值,至少要进行n次比较
然而继续在剩余的n-1个关键字中选择次小值并不一定要n-2次比较
利用关系的传递性,前n-1次比较所得的信息,可以减少以后各趟选择排序中所用的比较次数		
####树形选择排序
含有n个叶子结点的**完全二叉树**
形态是确定的,当n为奇数的时候
+ 构造这个完全二叉树的过程就是选出最小值的过程
最小值出现在根结点位置上
+ 中间的比较信息保存在了这个树结构中
+ 把最小值换成$\infty,然后从此叶节点再比较到根节点,就得到了次最小值$
+ 依次重复类似操作,得到次次最小值,次次次最小值,,,

缺点:需要较多的辅助存储空间
排序n个数,就要构造一棵含有n个叶子结点的完全二叉树

####堆排序
堆排序同样利用了树形选择排序用到的思想,但是改善了存储空间的要求
#####堆的定义
$n个元素的序列\\{k_1,k_2,\cdots,k_n\\}当且仅当满足如下关系时,称之为堆\\\
\begin{equation}
	小根堆
	\begin{cases}
	k_i \leqslant k_{2i}\\\
	k_i \leqslant k_{2i+1}
	\end{cases}
\end{equation}
堆顶元素取最小值
$
$
\begin{equation}
	大根堆
	\begin{cases}
	k_i \geqslant k_{2i}\\\
	k_i \geqslant k_{2i+1}	
	\end{cases}
\end{equation}
堆顶元素取最大值
$
**<u>堆是一个特殊的序列,若将和此序列对应的一维数组看成一个完全二叉树
则这棵完全二次树有这样的特点:所有非终端结点的值均不大于其左右孩子结点的值
(左右孩子结点的值的大小关系则不确定)
</u>**
###归并排序
###基数排序
###各个排序排序算法的比较,区别
+ 直接插入排序时在有序序列中找*插入*位置,
<u>比较操作在有序序列中进行</u>;
+ 简单选择排序时从无序序列中*选择*最小值作为有序序列的元素,
<u>比较操作(找最小值)在无序序列中进行</u>
+ 冒泡排序每次选出最大值顶到后面
<u>比较操作时相邻比较</u>

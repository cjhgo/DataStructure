viewport:width=device-width,initial-scale=1

目录

[TOC]

##sort排序
###概述
**排序确切的定义**
$含有n个记录的序列为\\{R_1,R_2,\cdots,R_n\\}\\\
其相应的关键字序列为\\{K_1,K_2,\cdots,K_n\\},\\\
需确定1,2,\cdots,n的一种排列为p_1,p_2,\cdots,p_n,使其相应的关键字满足非递减或非递增关系\\\
\quad\quad\quad K_{p_1}\leqslant K_{p_2}\leqslant \cdots K_{p_n}\\\
使序列称为一个按关键字有序的序列\\\
\quad\quad\quad \\{R_{p_1}, R_{p_2}, \cdots R_{p_n}\\}
如果K_i是主关键字,因其不允许重复,得到的排序结果是唯一的\\\$
如果K_i是次关键字,有可能存在两个或两个以上关键字相等,排序序列不唯一,
相应的排序方法就有<u>稳定与不稳定之分</u>

**内排序与外排序**

+ 内排序:记录一次读入内存
+ 外排序:记录过多无法一次读入内存,,??在排序过程中尚需对外存进行访问

**内排序方法分类**

+ 依据**<u>不同原则</u>**分类
	- 插入排序
	- 交换排序
	- 选择排序
	- 归并排序
	- 计数排序
+ 依据排序所需工作量分类
	- 简单排序方法,$O(n^2)$
	- 先进排序方法,$O(nlogn)$
	- 基数排序,$O(d\cdot n)$

**排序过程中的基本操作**

+ *比较*关键字大小
+ 将记录从一个位置*移动*至另一个位置
	- 通过改变记录存储方式避免
		+ 顺序存储
		+ 静态链表
		+ 顺序存储+地址向量
+ 讨论算法复杂度时,也就会分别讨论比较次数和移动次数		
###插入排序
####直接插入排序
思想
>将一个记录插入到已排好序的有序表中;
将序列中的第1个记录看出是一个有序的子序列,从第2个记录起逐个进行插入

**效率分析**

+ 空间复杂度:一个记录的辅助空间
+ 时间复杂度:
	- 最好情况:记录已经`正序`$O(n)$
		+ 比较次数:$\sum\limits_{i=2}^{n}1=n-1$
			- $a[i]只需要和a[i-1]比较一次进行了$
		+ 移动次数:不需要移动$0$
	- 最坏情况:记录`逆序`
		+ 比较次数:$\sum\limits_{i=2}^{n}i=\frac{(n-2)(n-1)}{2}$
			- $a[i]要一直比较到a[0],从a[0]到a[i-1]比较了i次$
		+ 移动次数:$\sum\limits_{i=2}^{n}i+1=\frac{(n+4)(n-1)}{2}$
			- $a[i]赋给a[0];a[1]-a[i-1]后移赋值;a[i]的值赋给a[1],\\\赋值操作共计i+1次$
	- <u>若待排序记录是随机的,即记录可能出现的各种排列概率相同,可以取最大值和最小值的平均值</u>$n^2/4$
	- 直接插入排序时间复杂度$O(n^2)$
####其他插入排序
#####折半插入排序
>用折半查找得到记录插入的位置,减少比较的次数,记录移动的次数不变

时间复杂度$O(n^2)$
#####2-路插入排序
需要n个记录的辅助空间作为一个循环向量
用first和final指针分别指向有序序列的收尾位置,(而不是按数组下标有序)
<u>来减少记录移动的次数</u>

当原始记录第一个键值是最值时,循环向量起不了作用,算法也无法减少记录移动次数
#####表插入排序
<u>通过使用静态链表来减少记录移动的次数</u>
??重排记录的做法,,?
####希尔排序,缩小增量排序
```c
ShellSort()
{
	// 增量序列,例如:9,5,3,...递减,也就是缩小增量序列
	dlta[0...t-1]
	for(k = 0; k < t; ++k)
	{
		/**
		**按dlta[k]的取值,对待排序序列按dlta[k]的间隔分成多个子序列
		**对各个子序列进行插入排序
		**子序列插入排序时,前后记录位置每次变化dlta[k],而不是1
		**/
		ShellInsert(L,dlta[k])
	}
}
```
###交换排序
借助`交换`排序
####冒泡排序
>比较相邻记录(的关键字),逆序时交换相邻记录,
每一趟排序使得关键字最大的记录被交换到 本趟范围内的最后一个位置
结束条件:在一趟排序过程中没有进行过交换记录的操作

**效率分析**

+ 时间复杂度分析
	- 最好情况:记录已经`正序`,只需$1$趟排序
	一趟排序中
		+ 比较$n-1次关键字,$
		+ $不移动记录$
	- 最坏情况:记录是`逆序`的,需要$n-1趟排序$
	在每趟排序中
		+ 比较$i-1次$,共计比较$\sum\limits_{i=n}^{2}(i-1)=n(n-1)/2次$
		+ 移动/交换$i-1次$,共计交换$\sum\limits_{i=n}^{2}(i-1)=n(n-1)/2次$
		
####快速排序
```c
void QuickSort(L)
{
	/**QSort递归调用
	**最终有序
	**/
	QSort(L,1(low),L.length(high))
				
		if(low < high)
		{			
					/**Partition:一趟快速排序
					**以L[low]为轴将L一份为二
					**得到一个pivot(轴)的位置(location)
					**使得轴左边的记录 < 轴 < 轴右边的记录
					**/
			PivotLoc=Partition(L,low,high)
			QSort(L,low,PivotLoc-1)
			QSort(L,PivotLoc+1,high)	
		}
}
```
**效率分析**
<u>就平均时间而言,快速排序目前被认为是最好的一种内部排序方法</u>

+ 时间复杂度分析
	- $T(n)为对n个记录进行快速排序所需时间,\\\
	T_{pass}(n)为对n个记录进行一趟快速排序所需时间\\\
	T(n)=T_{pass}(n)+T(k-1)+T(n-k),(PivotLoc=k)$
	- $T_{pass}(n)=cn,因为Partition是从表的两端交替地向中间扫描\\\
	只需遍历表一遍就可完成操作,时间复杂度O(n)=cn,c为某个常数$
	- $快速排序所需平均时间\\\
	记录随机排序,则一趟排序后,k去1-n之间任何一值概率相同\\\
	T_{avg}(n)=cn+ \frac{1}{n}\sum\limits_{k=1}^{n}[T_{avg}(k-1)+T_{avg}(n-k)]$

###选择排序
####简单选择排序
####树形选择排序,堆排序
###归并排序
###基数排序			
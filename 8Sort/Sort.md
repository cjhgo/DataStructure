viewport:width=device-width,initial-scale=1

目录

[TOC]

##sort排序
###概述
**排序确切的定义**
$含有n个记录的序列为\\{R_1,R_2,\cdots,R_n\\}\\\
其相应的关键字序列为\\{K_1,K_2,\cdots,K_n\\},\\\
需确定1,2,\cdots,n的一种排列为p_1,p_2,\cdots,p_n,使其相应的关键字满足非递减或非递增关系\\\
\quad\quad\quad K_{p_1}\leqslant K_{p_2}\leqslant \cdots K_{p_n}\\\
使序列称为一个按关键字有序的序列\\\
\quad\quad\quad \\{R_{p_1}, R_{p_2}, \cdots R_{p_n}\\}
如果K_i是主关键字,因其不允许重复,得到的排序结果是唯一的\\\$
如果K_i是次关键字,有可能存在两个或两个以上关键字相等,排序序列不唯一,
相应的排序方法就有<u>稳定与不稳定之分</u>

**内排序与外排序**

+ 内排序:记录一次读入内存
+ 外排序:记录过多无法一次读入内存,,??在排序过程中尚需对外存进行访问

**内排序方法分类**

+ 依据**<u>不同原则</u>**分类
	- 插入排序
	- 交换排序
	- 选择排序
	- 归并排序
	- 计数排序
+ 依据排序所需工作量分类
	- 简单排序方法,$O(n^2)$
	- 先进排序方法,$O(nlogn)$
	- 基数排序,$O(d\cdot n)$

**排序过程中的基本操作**

+ *比较*关键字大小
+ 将记录从一个位置*移动*至另一个位置
	- 通过改变记录存储方式避免
		+ 顺序存储
		+ 静态链表
		+ 顺序存储+地址向量
+ 讨论算法复杂度时,也就会分别讨论比较次数和移动次数		
###插入排序
####直接插入排序
思想
>将一个记录插入到已排好序的有序表中;
将序列中的第1个记录看出是一个有序的子序列,从第2个记录起逐个进行插入

**效率分析**

+ 空间复杂度:一个记录的辅助空间
+ 时间复杂度:
	- 最好情况:记录已经`正序`$O(n)$
		+ 比较次数:$\sum\limits_{i=2}^{n}1=n-1$
			- $a[i]只需要和a[i-1]比较一次进行了$
		+ 移动次数:不需要移动$0$
	- 最坏情况:记录`逆序`
		+ 比较次数:$\sum\limits_{i=2}^{n}i=\frac{(n-2)(n-1)}{2}$
			- $a[i]要一直比较到a[0],从a[0]到a[i-1]比较了i次$
		+ 移动次数:$\sum\limits_{i=2}^{n}i+1=\frac{(n+4)(n-1)}{2}$
			- $a[i]赋给a[0];a[1]-a[i-1]后移赋值;a[i]的值赋给a[1],\\\赋值操作共计i+1次$
	- <u>若待排序记录是随机的,即记录可能出现的各种排列概率相同,可以取最大值和最小值的平均值</u>$n^2/4$
	- 直接插入排序时间复杂度$O(n^2)$
####其他插入排序
#####折半插入排序
>用折半查找得到记录插入的位置,减少比较的次数,记录移动的次数不变

时间复杂度$O(n^2)$
#####2-路插入排序
需要n个记录的辅助空间作为一个循环向量
用first和final指针分别指向有序序列的收尾位置,(而不是按数组下标有序)
<u>来减少记录移动的次数</u>

当原始记录第一个键值是最值时,循环向量起不了作用,算法也无法减少记录移动次数
#####表插入排序
<u>通过使用静态链表来减少记录移动的次数</u>
??重排记录的做法,,?
####希尔排序,缩小增量排序
```c
ShellSort()
{
	// 增量序列,例如:9,5,3,...递减,也就是缩小增量序列
	dlta[0...t-1]
	for(k = 0; k < t; ++k)
	{
		/**
		**按dlta[k]的取值,对待排序序列按dlta[k]的间隔分成多个子序列
		**对各个子序列进行插入排序
		**子序列插入排序时,前后记录位置每次变化dlta[k],而不是1
		**/
		ShellInsert(L,dlta[k])
	}
}
```
###交换排序
借助`交换`排序
####冒泡排序

####快速排序
###选择排序
####简单选择排序
####树形选择排序,堆排序
###归并排序
###基数排序			
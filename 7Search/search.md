目录

[TOC]

##查找

###基本概念

基本操作

1. 查询某个特定的元素是否在查找表中
2. 检索某个特定的数据元素的各种属性
3. 在查找表中插入一个数据元素
4. 从查找表中删去某个数据元素

+ 关键字
	- 主关键字
	- 次关键字
+ 查找成功
+ 查找失败

###查找操作的性能分析

**平均查找长度**

查找成功时\\(ASL =  \sum\limits_{i=1}^{n}P_{i}C_{i}\\)
查找失败时

###静态查找(表)
对查找表只作1.2.这两种操作

####顺序表的顺序查找

+ 从最后一个记录开始向前查找
+ 设置elem[0]为监视哨,即赋查找值key给elem[0]:\\(elem[0].key = key;\\)
	- 不用在向前查找过程中每一步都判断是否越界,直接用判断是否相等作为循环条件,提高了平均查找时间
		+ 否则,如果不用监视哨,每一步在循环条件中判断是否越界,在循环体中判断是否相等,显然开销较大
	- 使得查找无论失败还是成功操作都一致(:都是返回一个下标索引值i)

性能分析

考虑各种情况

+ 查找成功的前提下
	- 最好的情况
	- 最坏的情况
	- 等概率的情况
	- 概率不等的情况
+ 查找有可能失败

####有序表的查找

**折半查找**
具体实现

+ 查找失败的判定条件:low <= high
+ 一次判断后
	- 相等,成功
	- data[mid] < key --: low = mid +1
	- key < data[mid] --: high = mid -1;

性能分析

+ 用判定树描述这个查找过程
	+ 结点的值为该记录在表中的位置
	+ \\(n个结点的判定树的深度为\\)
		- 折半查找法查找成功时比较的关键字个数不超过树的深度,至多为
	+ 引入内部结点,外部结点
		- 折半查找法查找不成功时比较的关键字个数也不超过树的深度,至多为
+ 平均查找长度
	
**斐波那契查找,,,,,(?)**
**插值插值,,,,,,,(?)**

####静态树表的查找

当有序表中各记录的查找概率不相等时,用来描述查找过程的**判定树**为何类二叉树时,其查找性能最佳,?
**最佳判定树**

\\(PH = \sum\limits_{i=1}^{n}w_{i}h_{i} ,最小\\)

**静态最优查找树,,,,,,,(?)**
**次优查找树,,,,,,,(?)**

####索引顺序查找/分块查找

###动态查找(表)
在查找过程中同时插入不存在的数据元素或从查找表中删除已存在的某个数据元素

####二叉排序树
####二叉平衡树
####\\(B-和B^{+}\\)树



####键树

###哈希表
####什么是哈希表
>在记录的存储位置和它的关键字之间建立一个确定的对应关系,不经过任何比较
一次存取便能得到所查记录

+ 冲突:不同的关键字得到同一个哈希地址
+ 同义词:具有相同函数值的关键字对哈希函数来说称作同义词
+ 哈希表:根据设定的哈希函数和处理冲突的方法,
将一组关键字**<u>映射</u>**到一个有限的连续地址集上,
并以关键字在地址集中的`像`作为记录在表中的存储位置
这种表称为哈希表
####哈希函数构造方法
均匀的哈希函数:使关键字的哈希地址均匀的分布在整个地址区间上
#####直接定址法
$取关键字或关键字的某个线性函数值为哈希地址\\\
H(key)=key 或 H(key)=a\cdot key + b$
#####数字分析法
$对应关键字是以r为基的数的情况,分析数的规律\\\
取关键字的若干位数位组成哈希地址$
#####平方取中法
$去关键字平方后的中间几位为哈希地址\\\
因为一个数平方后的中间几位数和数的每一位都相关$
#####折叠法
$将关键字分割成位数相同的几部分,然后取几部分的叠加和\\\
(舍去进位)作为哈希地址$
#####除留取余法
$关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址\\\
H(key) = key  MOD p, p \leqslant m\\\
合适的选择p能减少同义词的出现$

#####随机数法
$选择一个随机函数,取关键字的随机函数为它的哈希地址\\\
H(key) = random(key)$
####处理冲突的方法
处理冲突:为关键字的记录找到另一个'空'的哈希地址
$处理冲突的过程中可能得到一个地址序列\\\
H_i i=1,2,\cdots,k\\\
H_i 冲突发生后第i次探测的散列地址$
#####开放定址法
$H_i = ((H(key) + d_i ) MOD m \\\
\underline{m是哈希表表长}\\\
d_i是增量序列,有三种取法$
######线性探测再散列
$增量序列d_i是线性增长的\\\
例如;d_i=1,2,3,\cdots,m-1$

+ 二次聚集
处理冲突过程中发生的两个<u>第一个哈希地址不同的记录</u>
争夺同一个后继哈希地址的现象


######二次探测再散列
$d_i=1^2,-1^2,2^2,-2^2,3^2,\cdots,\pm k^2$


######伪随机序列
$d_i=伪随机序列$

+ 线性探测再散列可以保证:只要哈希表未填满,总能找到一个不发送冲突的地址$H_k$
+ 二次探测再散列只有哈希表长m为形如4j+3的素数时才可能,,,
+ 随机探测再散列取决于伪随机数列,,,
#####再哈希法
$H_i=RH_i(key)\\\
RH_1,RH_2,\cdots,RH_j是各部相同的哈希函数,即\\\
在同义词产生地址冲突时计算另一个哈希函数地址\\\
直到冲突不再发生$
#####链地址法
$将所有关键字为同义词的记录存储在同一个线性链表中\\\
设立一个大小为m的指针型向量,每个分量指向一个链表\\\
链表中的插入位置,表头,表尾,中间,都各有意义$
#####公共溢出区
记录发生冲突都填入溢出表
####哈希表的查找及其分析
>在哈希表上进行查找的过程和哈希表的构成过程基本一致


+ 给定K值,根据造表时设定的哈希函数求得哈希地址
	- 若表中此地址上没有记录则查找不成功
	- 否则比较关键字
		+ 若和给定值相等,则查找成功
		+ 否则,根据造表时设定的处理冲突的方法找`下一地址`
		直至为空,说明查找不成功;或找到给定值
		为止
	- **<u>查找不成功的唯一标识:按关键字(有可能使用冲突处理)最后到达了一个空记录</u>**
+ 哈希表的查找过程仍然是一个给定值和关键字进行比较的过程,
仍需要以平均查找长度作为衡量哈希表的查找效率的量度
+ **<u>虽然一开始,哈希函数是以不用比较,一次存取直接得到记录地址为目标的,但是
由于`冲突`的存在,有些时候还是要多次比较,才能确定查找成功或失败</u>**	
目录

[TOC]

##查找

###基本概念

基本操作

1. 查询某个特定的元素是否在查找表中
2. 检索某个特定的数据元素的各种属性
3. 在查找表中插入一个数据元素
4. 从查找表中删去某个数据元素

+ 关键字
	- 主关键字
	- 次关键字
+ 查找成功
+ 查找失败

###查找操作的性能分析

**平均查找长度**

查找成功时\\(ASL =  \sum\limits_{i=1}^{n}P_{i}C_{i}\\)
查找失败时

###静态查找(表)
对查找表只作1.2.这两种操作

####顺序表的顺序查找

+ 从最后一个记录开始向前查找
+ 设置elem[0]为监视哨,即赋查找值key给elem[0]:\\(elem[0].key = key;\\)
	- 不用在向前查找过程中每一步都判断是否越界,直接用判断是否相等作为循环条件,提高了平均查找时间
		+ 否则,如果不用监视哨,每一步在循环条件中判断是否越界,在循环体中判断是否相等,显然开销较大
	- 使得查找无论失败还是成功操作都一致(:都是返回一个下标索引值i)

性能分析

考虑各种情况

+ 查找成功的前提下
	- 最好的情况
	- 最坏的情况
	- 等概率的情况
	- 概率不等的情况
+ 查找有可能失败

####有序表的查找

**折半查找**
具体实现

+ 查找失败的判定条件:low <= high
+ 一次判断后
	- 相等,成功
	- data[mid] < key --: low = mid +1
	- key < data[mid] --: high = mid -1;

性能分析

+ 用判定树描述这个查找过程
	+ 结点的值为该记录在表中的位置
	+ \\(n个结点的判定树的深度为\\)
		- 折半查找法查找成功时比较的关键字个数不超过树的深度,至多为
	+ 引入内部结点,外部结点
		- 折半查找法查找不成功时比较的关键字个数也不超过树的深度,至多为
+ 平均查找长度
	
**斐波那契查找,,,,,(?)**
**插值插值,,,,,,,(?)**

####静态树表的查找

当有序表中各记录的查找概率不相等时,用来描述查找过程的**判定树**为何类二叉树时,其查找性能最佳,?
**最佳判定树**

\\(PH = \sum\limits_{i=1}^{n}w_{i}h_{i} ,最小\\)

**静态最优查找树,,,,,,,(?)**
**次优查找树,,,,,,,(?)**

####索引顺序查找/分块查找

###动态查找(表)
在查找过程中同时插入不存在的数据元素或从查找表中删除已存在的某个数据元素

####二叉排序树
####二叉平衡树
####\\(B-和B^{+}\\)树



####键树

###哈希表



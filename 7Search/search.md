目录

[TOC]

##查找

###基本概念
查找表是一种数据结构;
查找是一种操作::=
在一个含有众多的数据元素的查找表中找出某个特定的数据元素


(对查找表常进行的)操作

1. 查询某个特定的元素是否在查找表中
2. 检索某个特定的数据元素的各种属性
3. 在查找表中插入一个数据元素
4. 从查找表中删去某个数据元素

+ 关键字
	- 主关键字
	- 次关键字
+ 查找成功
+ 查找失败

###查找操作的性能分析

**平均查找长度**

+ 查找成功时$ASL_{成功} =  \sum\limits_{i=1}^{n}P_{i}C_{i}\\\
P_i::=查找 表中第i个记录的概率,\sum\limits_{i=1}^{n}=1,即,查找成功的范围内\\\
C_i::=找到表中其关键字与给定值相等的第i个记录时,\\\
和给定值已进行过比较的关键字个数
$	
+ 查找失败时

###静态查找(表)
对查找表只作1.2.这两种操作

####顺序查找
理清关系
不是顺序表的顺序查找
而是用顺序表或线性链表表示静态查找表,用`顺序查找`来实现查找
然后,讨论了顺序查找在顺序存储结构中的实现
还有在线性链表模块中的实现

+ 从最后一个记录开始向前查找
+ 设置elem[0]为监视哨,即赋查找值key给elem[0]:\\(elem[0].key = key;\\)
	- 不用在向前查找过程中每一步都判断是否越界,直接用判断是否相等作为循环条件,提高了平均查找时间
		+ 否则,如果不用监视哨,每一步在循环条件中判断是否越界,在循环体中判断是否相等,显然开销较大
	- 使得查找无论失败还是成功操作都一致(:都是返回一个下标索引值i)
#####具体实现
```c
//查找成功,返回下标i
//查找失败,比到了哨兵的位置,返回下标0
//length 是数据长度,数组长度=length+1(监视哨)
int search_seq(int data[],int length,int key)
{
	data[0] = key;
	int j = length;
	while(data[j] != key)
	{
		j--;
	}

	return j;
}
```		
#####性能分析

$顺序查找的C_i取决于所查找记录在表中的位置\\\
一般C_i=n-i+1\\\
ASL=nP_1+(n-1)P_2+\cdots+2P_{n-1}+P_n\\\
如果每个记录的查找概率相等,则P_i=1/n,\\\
ASL=\frac{1}{n}(n+ n-1 + n-2 + \cdots+1)=\frac{n+1}{2}$

有时,各个记录的查找概率并不相等,概率相当于权重,
要让查找概率高的的记录的查找长度尽可能短
所以,

+ 如果概率是已知的,应当使表中记录按查找概率的大小顺序重排
+ 如果概率无法预先测定,可以通过访问频度来记录相关信息

顺序查找,**查找不成功**,自然是把整个查找表都比较了一遍,
查找长度是${n+1}_{(和哨兵比了一次,+1)}$

<u>综合考虑查找成功的情形和不成功的情形时,</u>
$顺序查找的平均查找长度ASL=查找成功时的平均查找长度+查找不成功时的平均查找长度\\\
假设查找成功的可能性和不成功的可能性相同,每个记录的查找概率也相同\\\
ASL=\frac{1}{2}ASL_{成功}+ \frac{1}{2}ASL_{失败}\\\
=\frac{1}{2}\times \frac{1}{2}(n+1)+ \frac{1}{2}(n+1)\\\
=\frac{3}{4}(n+1)$



####有序表的查找


#####折半查找
######具体实现
```c
int search_bin(int data[],int length,int key)
{
	int low = 1;
	int high = length;
	int mid = (low + high) / 2;
	//查找失败的标志,low > high
	while(low <= high)
	{
		if(data[mid] == key) return mid;
		//注意这些细节,+1,-1,mid已经比过了,不用再比,要加一或减一
		else if(key < data[mid])  high = mid -1;
		else if(data[mid] < key)  low  = mid +1;
	}

	return 0;
}		
```

######性能分析

+ 用判定树描述这个查找过程
	+ 结点的值为**<u>该记录在表中的位置而不是关键字的值</u>**
		- 中间结点的位置存储在根结点;
		第一个结点位置存储在最左结点;
		最后一个结点位置存储在最右结点
	+ 查找表中某个记录,查找相当于从根结点走到了该记录对应的结点
	<u>和给定值比较的关键字个数等于该阶段在判定树上的层数</u>
		- $具有n个结点的判定树的深度不超过\lfloor log_2n\rfloor +1$和完全二叉树公式一样
		- 那么,查找某个记录 和给定值比较的关键字个数 最多 也就是这个数
	+ 引入**外结点**的概念:**所有结点的空指针域加上一个指向方形结点的指针**
	这些方形结点称为外结点
		- 查找不成功时,的过程,相当于走了一条从根结点到对应的外结点的路径
		和给定值比较的 关键字个数,等于该路径上<u>内部结点个数</u>
			+ 对应的外结点:$x\in [a[i],a[j]],x对应结点的值为[i\to j]$
			+ 是内部结点 的个数,不是什么内路径外路径,,,
				- 一个结点一层,内部结点 的个数 ,,就是最后一个内部结点的层数
				- 那么,查找不成功 比较的关键字个数 最多 也不超过$ 
				\lfloor log_2n\rfloor +1$这个数
	+ 引入内部结点,外部结点
		- 折半查找法查找不成功时比较的关键字个数也不超过树的深度,至多为
+ 平均查找长度
	- $查找成功时\\\
	假设P_i= \frac{1}{n},即每个记录查找概率相等\\\
	ASL= \sum\limits_{i=1}^{n}P_iC_i= \frac{1}{n}\sum\limits_{i=1}^{n}C_i,\\\
	=\frac{1}{n}\sum\limits_{j=1}^{h} j \cdot 2^{j-1},\\\
	解释:以层为单位,每层有2^{j-1}个结点,每个结点的查找长度为j\\\
	= \frac{n+1}{n}log_2(n+1)-1\\\
	\overset{n较大时}\sim log_2(n+1)-1$
+ 折半查找要求有序,并且要用顺序存储结构(因为线性链表不能直接存取某个位置的值)
	
#####斐波那契查找,,,,,(?)
#####插值插值,,,,,,,(?)

####静态树表的查找

当有序表中各记录的查找概率不相等时,用来描述查找过程的**判定树**为何类二叉树时,其查找性能最佳,?
**最佳判定树**

\\(PH = \sum\limits_{i=1}^{n}w_{i}h_{i} ,最小\\)

**静态最优查找树,,,,,,,(?)**
**次优查找树,,,,,,,(?)**

####索引顺序表的查找:分块查找
以索引顺序表来表示静态查找表,则可用分块查找来实现记录的查找
分块查找,是对顺序查找的改进;
#####为查找表建立索引表

+ 将查找表分成几个子表
+ 每个子表建立一个索引项,包括两个字段
	- 关键字项:子表内最大的关键字
	- 指针项:本子表第一个记录在查找表中的位置
+ **<u>索引顺序表要求查找表,至少分块有序</u>**,或者说,
要想使得到的索引表 按关键字有序,则查找表必须至少是 分块有序的
	- 如果索引表时无序的,那引入索引有没有意义呢,?没有	
#####具体实现
```c
//通过比较,得出,若查找的记录存在,必定在某个子表中::确定块
//根据指针项的地址,开始顺序查找,
//要么找到,要么到了边界,宣告查找不成功
```	
#####效率分析
+ 确定块的查找可以用顺序查找,也可以用折半查找
+ 块中记录的查找只能是顺序查找

分块查找的平均查找长度
$$ASL=L_{确定块}+L_{块中记录}$$

假设,分块查找,$将长度为n的表均匀分为b块,每块含有s个记录\\\
即b=\lceil n/s \rceil$
同时假设表中每个记录的查找概率相等,则

+ 每块查找概率为$ \frac{1}{b}$
+ 块中每个记录的查找概率为$ \frac{1}{s}$
+ 顺序查找索引表$ASL= \frac{b+1}{2}+ \frac{s+1}{2}\\\
= \frac{1}{2}( \frac{n}{s}+s)+1\\\
当查找表记录数n一定时,s取\sqrt{n}时,ASL取最小值\sqrt{n}+1$
+ 折半查找索引表$ASL\overset{\sim}= log_2( \frac{n}{s}+1)+ \frac{s}{2}$
###动态查找(表)
在查找过程中同时插入不存在的数据元素或从查找表中删除已存在的某个数据元素
<!-- #@TODO -->
####二叉排序树
####二叉平衡树
####\\(B-和B^{+}\\)树



####键树

###哈希表
####什么是哈希表
>在记录的存储位置和它的关键字之间建立一个确定的对应关系,不经过任何比较
一次存取便能得到所查记录

+ 冲突:不同的关键字得到同一个哈希地址
+ 同义词:具有相同函数值的关键字对哈希函数来说称作同义词
+ 哈希表:根据设定的哈希函数和处理冲突的方法,
将一组关键字**<u>映射</u>**到一个有限的连续地址集上,
并以关键字在地址集中的`像`作为记录在表中的存储位置
这种表称为哈希表
####哈希函数构造方法
均匀的哈希函数:使关键字的哈希地址均匀的分布在整个地址区间上
#####直接定址法
$取关键字或关键字的某个线性函数值为哈希地址\\\
H(key)=key 或 H(key)=a\cdot key + b$
#####数字分析法
$对应关键字是以r为基的数的情况,分析数的规律\\\
取关键字的若干位数位组成哈希地址$
#####平方取中法
$去关键字平方后的中间几位为哈希地址\\\
因为一个数平方后的中间几位数和数的每一位都相关$
#####折叠法
$将关键字分割成位数相同的几部分,然后取几部分的叠加和\\\
(舍去进位)作为哈希地址$
#####除留取余法
$关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址\\\
H(key) = key  MOD p, p \leqslant m\\\
合适的选择p能减少同义词的出现$

#####随机数法
$选择一个随机函数,取关键字的随机函数为它的哈希地址\\\
H(key) = random(key)$
####处理冲突的方法
处理冲突:为关键字的记录找到另一个'空'的哈希地址
$处理冲突的过程中可能得到一个地址序列\\\
H_i i=1,2,\cdots,k\\\
H_i 冲突发生后第i次探测的散列地址$
#####开放定址法
$H_i = ((H(key) + d_i ) MOD m \\\
\underline{m是哈希表表长}\\\
d_i是增量序列,有三种取法$
######线性探测再散列
$增量序列d_i是线性增长的\\\
例如;d_i=1,2,3,\cdots,m-1$

+ 二次聚集
处理冲突过程中发生的两个<u>第一个哈希地址不同的记录</u>
争夺同一个后继哈希地址的现象


######二次探测再散列
$d_i=1^2,-1^2,2^2,-2^2,3^2,\cdots,\pm k^2$


######伪随机序列
$d_i=伪随机序列$

+ 线性探测再散列可以保证:只要哈希表未填满,总能找到一个不发送冲突的地址$H_k$
+ 二次探测再散列只有哈希表长m为形如4j+3的素数时才可能,,,
+ 随机探测再散列取决于伪随机数列,,,
#####再哈希法
$H_i=RH_i(key)\\\
RH_1,RH_2,\cdots,RH_j是各部相同的哈希函数,即\\\
在同义词产生地址冲突时计算另一个哈希函数地址\\\
直到冲突不再发生$
#####链地址法
$将所有关键字为同义词的记录存储在同一个线性链表中\\\
设立一个大小为m的指针型向量,每个分量指向一个链表\\\
链表中的插入位置,表头,表尾,中间,都各有意义$
#####公共溢出区
记录发生冲突都填入溢出表
####哈希表的查找及其分析
>在哈希表上进行查找的过程和哈希表的构成过程基本一致


+ 给定K值,根据造表时设定的哈希函数求得哈希地址
	- 若表中此地址上没有记录则查找不成功
	- 否则比较关键字
		+ 若和给定值相等,则查找成功
		+ 否则,根据造表时设定的处理冲突的方法找`下一地址`
		直至为空,说明查找不成功;或找到给定值
		为止
	- **<u>查找不成功的唯一标识:按关键字(有可能使用冲突处理)最后到达了一个空记录</u>**
+ 哈希表的查找过程仍然是一个给定值和关键字进行比较的过程,
仍需要以平均查找长度作为衡量哈希表的查找效率的量度
+ **<u>虽然一开始,哈希函数是以不用比较,一次存取直接得到记录地址为目标的,但是
由于`冲突`的存在,有些时候还是要多次比较,才能确定查找成功或失败</u>**
#####三个影响因素
>查找过程中需和给定值进行比较的关键字个数
取决于下列三个因素
哈希函数,处理冲突的方法,哈希表的装填因子

**哈希表的$\underline{ASL,平均查找长度}$**:
查找过程中<u>查找值和表中值的平均比较次数</u>

+ 用哈希函数算出地址要比较一次
+ 每次冲突后新算出的地址要比较一次


+ **哈希函数**影响ASL
	+ 哈希函数的好坏影响冲突出现的频繁程度
	+ 对于均匀的哈希函数可以假定:<u>不同的哈希函数(只要同样是均匀的)
	对同一组随机的关键字,产生冲突的可能性相同</u>
		- 也就是说,当哈希函数同样均匀,影响ASL的就不是哈希函数了而是
			+ **处理冲突的方法**影响ASL
			比如,线性探测再散列这种冲突处理方法容易产生二次聚集
			而链地址法不会产生;在上面的具体实例中可以看出二者ASL的不同
				- 如果处理冲突方法相同,此时影响ASL的就是				
					+ **装填因子**影响ASL
					$装填因子\alpha = \frac{表中填入记录数}{哈希表长度}\\\
					标志着哈希表的装满程度$
+ 通过数学推导,,....可以证明
$ASL_{成功/失败}=F(\alpha),也就是说,\underline{哈希表的平均查找长度是\alpha的函数}\\\
不管n多大,我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围内$			
	- $\alpha直接影响/决定ASL,\\\
	表长m和表中填入记录数n决定了\alpha\\\
	所以,通过调整m可以在n一定时影响ASL$
	- 直观的看,$\alpha越小,发生冲突的可能性越小;\\\
	\alpha越大,表中已填入的记录越多,再填记录时,发生冲突的可能性就越大\\\
	查找时,给定值需与之进行比较的关键字个数也就越多$
+ **<u>查找不成功时的ASL</u>**
定义:查找不成功时需和给定值进行比较的平均关键字个数 
	+ 很关键的一句话,指导了$ASL_{失败}$怎么算的一句话
	$分析表长为m的哈希表中装填有n个记录时查找不成功的平均查找长度\\\
	\underline{相当于\quad要求在这张表中填入第n+1个记录时所需作的平均比较次数}$
		- $如果哈希函数是均匀的,那么H(key_{n+1})等概率的取[0,m-1]中的任何一个值\\\
		也就是说第n+1个记录存入第j个地址的概率是 \frac{1}{m},\\\
		那么由于冲突的存在,要进行冲突处理,就会接着再计算查找几次,最终找到一个位置\\\
		所以ASL_{失败}= \frac{1}{m}(f_0+f_1+\cdots+f_{m-1})\\\$
			+ $假设,经过计算H(key_{n+1})=j,,如何计算f_j\\\$
				- $如果表中j处没有记录,那么只需一次比较,?探测,?就找到了存入位置$
				- $如果表中j处已有记录,根据是链地址法,还是线性探测再散列,判断一下\\\
				找到最终的位置,需要几次 比较,?探测,?\\\
				就知道了f_j是多少$
+ 在非链地址处理冲突的哈希表中<u>删除一个记录时</u>,
**需在该记录的位置上填入一个特殊的符号**
以免找不到它之后的`同义词`的记录
	- 如果不做特殊标记,查找时就会提前查找结束,(以为到这儿就结束了)
	使得本来存在的记录没被找到
+ 对于预先知道的确定的关键字集合,可以设计出一个完美的/不需要处理冲突的哈希函数	

举例说明查找成功时的平均查找长度的计算
$关键字\\{19,14,23,01,68,20,84,27,55,11,10,79\\}\\\
哈希函数:H(key)=key MOD 13\\\$

**线性探测再散列**

|key|19|14|23|01|68|20|84|27|55|11|10|79|
|-|-|-|-|-|-|-|-|-|-|-|-|-|
|%13,H(key)|6|1|10|1|3|7|6|1|3|11|10|1|
|$H_1$||||2|||7|2|4||11|2|
|$H_2$|||||||8|3|5||12|3|
|$H_3$||||||||4||||4|
|$H_4$||||||||||||5|
|$H_i$||||||||||||$\vdots$|
|$H_8$||||||||||||9|

$ASL_{成功}= \frac{1}{12}(1_{19}+1_{14}+1_{23}+2_{01}+1_{68}+1_{20}+3_{84}+4_{27}+3_{55}+1_{11}+3_{10}+9_{79})\\\
=2.5\\\
解释:4_{27}:查找27要查找4次,\\\
\quad\quad\quad\quad 用哈希函数算出一个地址,查找比较一次,没找到\\\
\quad\quad\quad\quad 冲突后得到H_1,查找比较一次,没找到\\\
\quad\quad\quad\quad 冲突后得到H_2,查找比较一次,没找到\\\
\quad\quad\quad\quad 冲突后得到H_3,查找比较一次,查找成功\\\
$


**链地址法**

|HEAD||||||
|-|-|-|-|-|-|
|0||||||
|1$\to$|01$\to$|14$\to$|27$\to$|79$\to$|NULLL|
|2||||||
|3$\to$|55$\to$|68$\to$|NULL
|4||||||
|5||||||
|6$\to$|19$\to$|84$\to$|NULL
|7$\to$|20$\to$|NULL||
|8||||||
|9||||||
|6$\to$|10$\to$|23$\to$|NULL
|7$\to$|11$\to$|NULL||
|12|||||||||||

(同一链表中关键字自小到大有序)
$ASL_{成功}= \frac{1}{12}($$1_{01}+2_{14}+3_{27}+4_{79}+\\\
1_{55}+2_{68}+\\\
1_{19}+2_{84}+\\\
1_{20}+\\\
1_{10}+2_{23}+\\\
1_{11})\\\
=1.75\\\
解释:3_{27}:查找27要查找3次,才能查找成功\\\
27在所在链表的第3个位置,查找3次才找到\\\
表中的各个链表是记录的键值大小排序的,保证了只要顺序查找要么找到要么找不到\\\
如果各个链表是乱序的,那么每一个,是不是,,就不一样了,,????$

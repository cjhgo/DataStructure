目录

[TOC]

##查找

###基本概念
查找表是一种数据结构;
查找是一种操作::=
在一个含有众多的数据元素的查找表中找出某个特定的数据元素


(对查找表常进行的)操作

1. 查询某个特定的元素是否在查找表中
2. 检索某个特定的数据元素的各种属性
3. 在查找表中插入一个数据元素
4. 从查找表中删去某个数据元素

+ 关键字
	- 主关键字
	- 次关键字
+ 查找成功
+ 查找失败

###查找操作的性能分析

**平均查找长度**

+ 查找成功时$ASL_{成功} =  \sum\limits_{i=1}^{n}P_{i}C_{i}\\\
P_i::=查找 表中第i个记录的概率,\sum\limits_{i=1}^{n}=1,即,查找成功的范围内\\\
C_i::=找到表中其关键字与给定值相等的第i个记录时,\\\
和给定值已进行过比较的关键字个数
$	
+ 查找失败时

###静态查找(表)
对查找表只作1.2.这两种操作

####顺序查找
理清关系
不是顺序表的顺序查找
而是用顺序表或线性链表表示静态查找表,用`顺序查找`来实现查找
然后,讨论了顺序查找在顺序存储结构中的实现
还有在线性链表模块中的实现

+ 从最后一个记录开始向前查找
+ 设置elem[0]为监视哨,即赋查找值key给elem[0]:\\(elem[0].key = key;\\)
	- 不用在向前查找过程中每一步都判断是否越界,直接用判断是否相等作为循环条件,提高了平均查找时间
		+ 否则,如果不用监视哨,每一步在循环条件中判断是否越界,在循环体中判断是否相等,显然开销较大
	- 使得查找无论失败还是成功操作都一致(:都是返回一个下标索引值i)

#####性能分析

$顺序查找的C_i取决于所查找记录在表中的位置\\\
一般C_i=n-i+1\\\
ASL=nP_1+(n-1)P_2+\cdots+2P_{n-1}+P_n\\\
如果每个记录的查找概率相等,则P_i=1/n,\\\
ASL=\frac{1}{n}(n+ n-1 + n-2 + \cdots+1)=\frac{n+1}{2}$

有时,各个记录的查找概率并不相等,概率相当于权重,
要让查找概率高的的记录的查找长度尽可能短
所以,

+ 如果概率是已知的,应当使表中记录按查找概率的大小顺序重排
+ 如果概率无法预先测定,可以通过访问频度来记录相关信息

顺序查找,**查找不成功**,自然是把整个查找表都比较了一遍,
查找长度是${n+1}_{(和哨兵比了一次,+1)}$

<u>综合考虑查找成功的情形和不成功的情形时,</u>
$顺序查找的平均查找长度ASL=查找成功时的平均查找长度+查找不成功时的平均查找长度\\\
假设查找成功的可能性和不成功的可能性相同,每个记录的查找概率也相同\\\
ASL=\frac{1}{2}ASL_{成功}+ \frac{1}{2}ASL_{失败}\\\
=\frac{1}{2}\times \frac{1}{2}(n+1)+ \frac{1}{2}(n+1)\\\
=\frac{3}{4}(n+1)$



####有序表的查找

**折半查找**
具体实现

+ 查找失败的判定条件:low <= high
+ 一次判断后
	- 相等,成功
	- data[mid] < key --: low = mid +1
	- key < data[mid] --: high = mid -1;

性能分析

+ 用判定树描述这个查找过程
	+ 结点的值为该记录在表中的位置
	+ \\(n个结点的判定树的深度为\\)
		- 折半查找法查找成功时比较的关键字个数不超过树的深度,至多为
	+ 引入内部结点,外部结点
		- 折半查找法查找不成功时比较的关键字个数也不超过树的深度,至多为
+ 平均查找长度
	
**斐波那契查找,,,,,(?)**
**插值插值,,,,,,,(?)**

####静态树表的查找

当有序表中各记录的查找概率不相等时,用来描述查找过程的**判定树**为何类二叉树时,其查找性能最佳,?
**最佳判定树**

\\(PH = \sum\limits_{i=1}^{n}w_{i}h_{i} ,最小\\)

**静态最优查找树,,,,,,,(?)**
**次优查找树,,,,,,,(?)**

####索引顺序查找/分块查找

###动态查找(表)
在查找过程中同时插入不存在的数据元素或从查找表中删除已存在的某个数据元素

####二叉排序树
####二叉平衡树
####\\(B-和B^{+}\\)树



####键树

###哈希表
####什么是哈希表
>在记录的存储位置和它的关键字之间建立一个确定的对应关系,不经过任何比较
一次存取便能得到所查记录

+ 冲突:不同的关键字得到同一个哈希地址
+ 同义词:具有相同函数值的关键字对哈希函数来说称作同义词
+ 哈希表:根据设定的哈希函数和处理冲突的方法,
将一组关键字**<u>映射</u>**到一个有限的连续地址集上,
并以关键字在地址集中的`像`作为记录在表中的存储位置
这种表称为哈希表
####哈希函数构造方法
均匀的哈希函数:使关键字的哈希地址均匀的分布在整个地址区间上
#####直接定址法
$取关键字或关键字的某个线性函数值为哈希地址\\\
H(key)=key 或 H(key)=a\cdot key + b$
#####数字分析法
$对应关键字是以r为基的数的情况,分析数的规律\\\
取关键字的若干位数位组成哈希地址$
#####平方取中法
$去关键字平方后的中间几位为哈希地址\\\
因为一个数平方后的中间几位数和数的每一位都相关$
#####折叠法
$将关键字分割成位数相同的几部分,然后取几部分的叠加和\\\
(舍去进位)作为哈希地址$
#####除留取余法
$关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址\\\
H(key) = key  MOD p, p \leqslant m\\\
合适的选择p能减少同义词的出现$

#####随机数法
$选择一个随机函数,取关键字的随机函数为它的哈希地址\\\
H(key) = random(key)$
####处理冲突的方法
处理冲突:为关键字的记录找到另一个'空'的哈希地址
$处理冲突的过程中可能得到一个地址序列\\\
H_i i=1,2,\cdots,k\\\
H_i 冲突发生后第i次探测的散列地址$
#####开放定址法
$H_i = ((H(key) + d_i ) MOD m \\\
\underline{m是哈希表表长}\\\
d_i是增量序列,有三种取法$
######线性探测再散列
$增量序列d_i是线性增长的\\\
例如;d_i=1,2,3,\cdots,m-1$

+ 二次聚集
处理冲突过程中发生的两个<u>第一个哈希地址不同的记录</u>
争夺同一个后继哈希地址的现象


######二次探测再散列
$d_i=1^2,-1^2,2^2,-2^2,3^2,\cdots,\pm k^2$


######伪随机序列
$d_i=伪随机序列$

+ 线性探测再散列可以保证:只要哈希表未填满,总能找到一个不发送冲突的地址$H_k$
+ 二次探测再散列只有哈希表长m为形如4j+3的素数时才可能,,,
+ 随机探测再散列取决于伪随机数列,,,
#####再哈希法
$H_i=RH_i(key)\\\
RH_1,RH_2,\cdots,RH_j是各部相同的哈希函数,即\\\
在同义词产生地址冲突时计算另一个哈希函数地址\\\
直到冲突不再发生$
#####链地址法
$将所有关键字为同义词的记录存储在同一个线性链表中\\\
设立一个大小为m的指针型向量,每个分量指向一个链表\\\
链表中的插入位置,表头,表尾,中间,都各有意义$
#####公共溢出区
记录发生冲突都填入溢出表
####哈希表的查找及其分析
>在哈希表上进行查找的过程和哈希表的构成过程基本一致


+ 给定K值,根据造表时设定的哈希函数求得哈希地址
	- 若表中此地址上没有记录则查找不成功
	- 否则比较关键字
		+ 若和给定值相等,则查找成功
		+ 否则,根据造表时设定的处理冲突的方法找`下一地址`
		直至为空,说明查找不成功;或找到给定值
		为止
	- **<u>查找不成功的唯一标识:按关键字(有可能使用冲突处理)最后到达了一个空记录</u>**
+ 哈希表的查找过程仍然是一个给定值和关键字进行比较的过程,
仍需要以平均查找长度作为衡量哈希表的查找效率的量度
+ **<u>虽然一开始,哈希函数是以不用比较,一次存取直接得到记录地址为目标的,但是
由于`冲突`的存在,有些时候还是要多次比较,才能确定查找成功或失败</u>**
#####三个影响因素
>查找过程中需和给定值进行比较的关键字个数
取决于下列三个因素
哈希函数,处理冲突的方法,哈希表的装填因子

**哈希表的$\underline{ASL,平均查找长度}$**:
查找过程中<u>查找值和表中值的平均比较次数</u>

+ 用哈希函数算出地址要比较一次
+ 每次冲突后新算出的地址要比较一次


+ **哈希函数**影响ASL
	+ 哈希函数的好坏影响冲突出现的频繁程度
	+ 对于均匀的哈希函数可以假定:<u>不同的哈希函数(只要同样是均匀的)
	对同一组随机的关键字,产生冲突的可能性相同</u>
		- 也就是说,当哈希函数同样均匀,影响ASL的就不是哈希函数了而是
			+ **处理冲突的方法**影响ASL
			比如,线性探测再散列这种冲突处理方法容易产生二次聚集
			而链地址法不会产生;在上面的具体实例中可以看出二者ASL的不同
				- 如果处理冲突方法相同,此时影响ASL的就是				
					+ **装填因子**影响ASL
					$装填因子\alpha = \frac{表中填入记录数}{哈希表长度}\\\
					标志着哈希表的装满程度$
+ 通过数学推导,,....可以证明
$ASL_{成功/失败}=F(\alpha),也就是说,\underline{哈希表的平均查找长度是\alpha的函数}\\\
不管n多大,我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围内$			
	- $\alpha直接影响/决定ASL,\\\
	表长m和表中填入记录数n决定了\alpha\\\
	所以,通过调整m可以在n一定时影响ASL$
	- 直观的看,$\alpha越小,发生冲突的可能性越小;\\\
	\alpha越大,表中已填入的记录越多,再填记录时,发生冲突的可能性就越大\\\
	查找时,给定值需与之进行比较的关键字个数也就越多$
+ **<u>查找不成功时的ASL</u>**
定义:查找不成功时需和给定值进行比较的平均关键字个数 
	+ 很关键的一句话,指导了$ASL_{失败}$怎么算的一句话
	$分析表长为m的哈希表中装填有n个记录时查找不成功的平均查找长度\\\
	\underline{相当于\quad要求在这张表中填入第n+1个记录时所需作的平均比较次数}$
		- $如果哈希函数是均匀的,那么H(key_{n+1})等概率的取[0,m-1]中的任何一个值\\\
		也就是说第n+1个记录存入第j个地址的概率是 \frac{1}{m},\\\
		那么由于冲突的存在,要进行冲突处理,就会接着再计算查找几次,最终找到一个位置\\\
		所以ASL_{失败}= \frac{1}{m}(f_0+f_1+\cdots+f_{m-1})\\\$
			+ $假设,经过计算H(key_{n+1})=j,,如何计算f_j\\\$
				- $如果表中j处没有记录,那么只需一次比较,?探测,?就找到了存入位置$
				- $如果表中j处已有记录,根据是链地址法,还是线性探测再散列,判断一下\\\
				找到最终的位置,需要几次 比较,?探测,?\\\
				就知道了f_j是多少$
+ 在非链地址处理冲突的哈希表中<u>删除一个记录时</u>,
**需在该记录的位置上填入一个特殊的符号**
以免找不到它之后的`同义词`的记录
	- 如果不做特殊标记,查找时就会提前查找结束,(以为到这儿就结束了)
	使得本来存在的记录没被找到
+ 对于预先知道的确定的关键字集合,可以设计出一个完美的/不需要处理冲突的哈希函数	

举例说明查找成功时的平均查找长度的计算
$关键字\\{19,14,23,01,68,20,84,27,55,11,10,79\\}\\\
哈希函数:H(key)=key MOD 13\\\$

**线性探测再散列**

|key|19|14|23|01|68|20|84|27|55|11|10|79|
|-|-|-|-|-|-|-|-|-|-|-|-|-|
|%13,H(key)|6|1|10|1|3|7|6|1|3|11|10|1|
|$H_1$||||2|||7|2|4||11|2|
|$H_2$|||||||8|3|5||12|3|
|$H_3$||||||||4||||4|
|$H_4$||||||||||||5|
|$H_i$||||||||||||$\vdots$|
|$H_8$||||||||||||9|

$ASL_{成功}= \frac{1}{12}(1_{19}+1_{14}+1_{23}+2_{01}+1_{68}+1_{20}+3_{84}+4_{27}+3_{55}+1_{11}+3_{10}+9_{79})\\\
=2.5\\\
解释:4_{27}:查找27要查找4次,\\\
\quad\quad\quad\quad 用哈希函数算出一个地址,查找比较一次,没找到\\\
\quad\quad\quad\quad 冲突后得到H_1,查找比较一次,没找到\\\
\quad\quad\quad\quad 冲突后得到H_2,查找比较一次,没找到\\\
\quad\quad\quad\quad 冲突后得到H_3,查找比较一次,查找成功\\\
$


**链地址法**

|HEAD||||||
|-|-|-|-|-|-|
|0||||||
|1$\to$|01$\to$|14$\to$|27$\to$|79$\to$|NULLL|
|2||||||
|3$\to$|55$\to$|68$\to$|NULL
|4||||||
|5||||||
|6$\to$|19$\to$|84$\to$|NULL
|7$\to$|20$\to$|NULL||
|8||||||
|9||||||
|6$\to$|10$\to$|23$\to$|NULL
|7$\to$|11$\to$|NULL||
|12|||||||||||

(同一链表中关键字自小到大有序)
$ASL_{成功}= \frac{1}{12}($$1_{01}+2_{14}+3_{27}+4_{79}+\\\
1_{55}+2_{68}+\\\
1_{19}+2_{84}+\\\
1_{20}+\\\
1_{10}+2_{23}+\\\
1_{11})\\\
=1.75\\\
解释:3_{27}:查找27要查找3次,才能查找成功\\\
27在所在链表的第3个位置,查找3次才找到\\\
表中的各个链表是记录的键值大小排序的,保证了只要顺序查找要么找到要么找不到\\\
如果各个链表是乱序的,那么每一个,是不是,,就不一样了,,????$

目录

[TOC]

------

##图
###图的定义和术语

+ 图
	- \\(G= (V,{E}),\\)
		+ \\(V=\\{v_{1},v_{2},v_{3},v_{4},....\\}\\)
		+ \\(E =\\{ (v_{i},v_{j} )... \\}\\)或者\\(E =\\{ < v_{i},v_{j} > ...\\}\\)
+ 顶点,Vertex
+ 有向图:&ensp;&ensp;弧Arc \\( < v,w > \in VR\\)
	- v 弧尾
	- w 弧头
+ 无向图:&ensp;&ensp;边
+ \\(用n表示图中顶点的数目,e表示图中边/弧的数目\\),不考虑顶点到自身的弧或边
	- 无向图 \\(e \in [0,\frac{1}{2}n(n-1)]\\)
		+ 完全图:有\\(\frac{1}{2}n(n-1)\\)条边的无向图
	- 有向图 \\(e \in [0,n(n-1)]\\)
		+ 有向完全图:有\\(n(n-1)\\)条边的有向图
	- 稀疏图: 边/弧比较少
	- 稠密图: 边/弧比较多
+ 权:与图的边/弧相关的数
	- 带权的图称为**网**
+ 子图
+ 无向图
	- 邻接点
	- 依附
	- 相关联
	- 度
+ 有向图
	- 邻接到,邻接自
	- 入度,出度,度
+ 度\\(TD(v)\\)
	- \\(e=\frac{1}{2}\sum\limits_{i=1}^{n}TD(v_{i})\\)
+ 路径:&ensp;&ensp;
	- 回路/环:第一个顶点和最后一个顶点相同的路径
	- 简单路径:序列张不重复出现的路径
	- 简单回路/简单环:除了第一个顶点和最后一个顶点外,其余顶点不重复出现的回路
+ 连通
	- 在无向图中
		+ 图的两个顶点连通:顶点之间有路径
		+ 图的连通**连通图**:任意两个顶点连通
		+ **连通分量**:&ensp;&ensp;无向图的**极大**连通子图
		+ **生成树**:&ensp;&ensp;&ensp;&ensp;连通图的**极小**连通子图
			- 一个极小连通子图:含有图的全部顶点,但有且只有足以构成一棵树的\\(n-1\\)条边
			- 生成树的一些结论....(?)		
	- 在有向图中
		+ 图的两个顶点连通:\\(从v_{i}到v_{j}和从v_{j}到v_{i}\\)都存在路径
		+ 强连通图
		+ 强连通分量
		+ 有向图的**生成森林**.......(?)
	- 理清这些关系,,,,:
		+ 无向图的叫连通分量,连通图;有向图的叫强连通分量,强连通图;
		+ 连通分量,连通图,非连通图,,,,,
		+ 连通分量是极大连通子图,生成树是极小连通子图
------

###图的存储结构
存储结构的复杂度分析,,,,(?)

+ 有向图/无向图通用结构
	- **数组表示法**
		+ 两个矩阵,一个用来存储顶点信息,一个用来存储边/弧的信息
			- 无向图的边信息矩阵是一个对称矩阵	
	- **邻接表**(每一个顶点建立一个单链表,表示依附于顶点的边/(弧....))
		+ 容易找到任意顶点的各个邻接点,但若要判断任意两个顶点之间是否有边/弧相连,要遍历链表,不如矩阵方便
		+ 无向图的边会在出现两次....
+ 有向图的另一种链式存储结构:&ensp;&ensp;**十字链表**
	- 十字链表的建立可以这样理解:
		+ 每个顶点(每一个顶点有两个链表)
			- 有一个data域,用来存储顶点信息
			- 有两个链域,是两个头结点,相当于两个链表,初始时皆为NULL
		+ 每次读入一条弧的时候,找到弧头弧尾,就是**找到相应的头结点,在头结点后插入这条弧(最先读入的弧会在最后)**
		+ 读入所有弧之后,每次都正确的插入,修改链域信息后,就得到十字链表
		+ 一个角度可以理解为将有向图的邻接表和逆邻接表结合起来,另一个角度,这是邻接矩阵的十字链表表示法
	+ 既容易找到一\\(v_{i}\\)为尾的弧,也容易找到以\\(v_{j}\\)为头的弧
	+ 建立的时间复杂度...(?)
+ 无向图的另一种链式存储结构:&ensp;&ensp;**邻接多重表**(每个顶点一个结点,每条边一个结点)

------

###图的遍历

####深度优先搜索
使用栈(递归调用),类似树的先根遍历

+ 选择一个顶点\\(v\\)出发,访问此顶点,然后
	- 依次从\\(v\\)的未被访问的邻接点出发深度优先遍历图(递归)			
		+ 找到**未被访问的邻接点**需要的操作
			- 记录已被访问的顶点
			- 根据选择的存储结构,得到某顶点的邻接点 
		+ 一个顶点的所有邻接点都被访问后,就会回溯到上一层(退栈,一次函数递归调用return)
	- 直至所有和\\(v\\)有路径相通的顶点都被访问到
+ 若此时图中尚有未被访问的顶点,则从中另选一个做起点,开始深度优先遍历	

####广度优先搜索
使用队列,类似树的按层次遍历(也是用队列实现)

+ 从某一顶点\\(v\\)出发,一次访问各个未曾访问的邻接点
	- 再从这些邻接点一次出发范围它们的邻接点并使**先被访问的顶点的邻接点**先于**后被访问的顶点的邻接点**被访问(通过队列实现)
	- 直至所有和\\(v\\)有路径相通的顶点都被访问到
+ 若此时图中尚有未被访问的顶点,则从中另选一个做起点,开始广度优先遍历			

------

###图的连通性问题


**遍历得到的是顶点集**

####无向图的连通分量和生成树

- 如果一个图是非连通图,在深度/广度优先遍历的过程中会自然生成一个个连通分量**的顶点集**
	+ 体现在遍历时重新选择顶点这一步之中
+ 遍历过程中得到的是一个连通分量的顶点集
	- 这些顶点集加上所有依附于这些顶点的边,构成了**连通分量**
	- 这些顶点集加上遍历过程中历经的边,构成了**生成树**
- 连通分量对应于遍历产生的生成森林(顶点集对应....)
- 如何修改遍历算法记录这些连通分量(..?)

####求有向图的强连通分量

- 深度优先搜索完成后,沿着顶点接着逆向深度优先搜索,每次逆向搜索的停顿得到一个强连通分量的顶点集
	+ 逆向对应于有向图的两个顶点的连通指的是双向连通
####最小生成树
对于\\(n\\)个顶点的连通网可以建立许多不同的生成树,每一棵生成树都可以是一个通信网(使\\(n\\)个顶点之间互通),选择这样一棵生成树,使得中的耗费最少.这个耗费最少用边/弧上的权来刻画

最小生成树的MST性质:.......

每一步都是最小的,一步一步最终得到了最小的

+ Prim算法:逐步扩大(....?)
	- 从\\(U=\\{u_{0}\\},TE=\\{\\}\\)开始
	- 在\\(U 和 (U-V)\\)之间找具有最小代价的边
+ Kruskal算法:逐步合并(..是这么描述吗,)(....?)
	- 从\\(U=\\{V\\},TE=\\{\\}\\)开始
	- 找最小代价的边判断是否在不同的连通分量之中

####重连通分量

- 关节点
- 重连通图
- 图的连通度

可以用来描述系统的稳定性(需要破坏k个顶点,才能使整个网不通)

由深度优先生成树可以得出两类关节点的特性:

- 若生成树的根有两棵或两棵以上的子树,则此根顶点必为**关节点**
	- 因为图中不存在联结不同子树中顶点(任意树结点)的边,所以若删除根顶点,生成树变生成森林
		+ (**如果存在,就会在深度优先遍历过程中成为同一棵子树上的结点)
- 若生成树中某个非叶子顶点\\(v\\),其某棵子树的根和子树中的其他结点都没有指向\\(v\\)的祖先的回边,则\\(v\\)为**关节点**

在深度优先搜索中求得连通图所有关节点的算法(...?)
利用深度优先搜索,在搜索过程中记录序号....得到关节点

+ 引入次序号\\(visited[v]\\)
+ 引入\\(low[w]\\)
......
------

###有向无环图及其应用

####检查无环图

+ 无向图
	- 若深度优先遍历过程中遇到回边(指向已访问过的顶点的边),必定存在环
		+ 遇到回边,指向已访问过的顶点,必定能再从这个访问过的顶点沿着之前的访问轨迹访问到自己,这就成了一个环
+ 有向图
	- 若深度优先遍历过程中遇到已访问过得顶点,却不一定有环
		+ 若这个已访问过得顶点是出发的顶点,则能沿着轨迹访问到自己,,可以说明有环
		+ 若这个已访问过得顶点不是出发的顶点,则并不能保证沿着轨迹能访问到自己,也许是指向了深度优先生成森林中的另一棵子树

####有向无环图描述工程或系统

+ 工程能否顺利进行
+ 估算工程完成所必须的最短时间
#####拓扑排序,AOV
由一个偏序得到一个全序

**AOV网**
不能有环<->是否(所有顶点都在拓扑有序序列之中)

**如何拓扑排序(....?)**

+ 选一个没有前驱/入度为0的顶点,输出之
+ 从图中删除该顶点和所有以它为尾的弧
+ 重复上两步,直到
	- 输出所有顶点
	- 或者,找不到没有前驱的顶点(说明有环)

**利用深度优先遍历求逆拓扑排序**

+ 最先退出DFS(深度优先遍历)函数的顶点是出度为0的顶点....?

#####关键路径,AOE

用边表示活动
用结点表示事件
整个工程无环
只有一个开始点是入度为0的那个点,称为源点
只有一个结束点是出度为0的那个点,称为汇点

工程中的有些活动是可以并行进行的
完成工程的最短时间,也就是至少要用的时间
取决于
从源点到汇点的最长路径的长度(路径上各活动持续时间之和)
这个另叫作**关键路径**




------

###最短路径

####从某个源点到其余各个顶点的最短路径,Dijkstra算法
[迪杰斯特拉算法(Dijkstra)的本质是贪心还是动态规划? ](http://www.zhihu.com/question/22311234)
####每一对顶点之间的最短路径,Floyd算法





仿照递归算法执行过程中递归工作栈的状态
可以写出非递归算法

其实没这么简单



遍历的递归算法看起来简单符合人类的思维逻辑,效率低
非递归算法,其实不是那么好写

递归工作栈记录了哪些信息,?
递归工作栈和自己手动写的栈的有一个很大的不同
那就是递归工作栈有一个上下文的执行环境
不但记录了需要的变量,还有接下来的动作
有点状态机的意思
状态+动作

递归工作栈知道
从左子树退栈后(递归调用return)该干嘛
从右子树退栈后(递归调用return)该干嘛
是接着遍历还是本层函数调用结束

调试观察递归遍历的执行过程,确实是在进栈退栈
这些是系统维护实现的,系统有断点,有寄存器,有IP指针

可是,我们自己实现非递归算法时,怎么做到这些呢,?

有一点启示是
我们需要自己维护一个栈,直到栈空,对应着递归调用结束,对应着问题解决
这必然是一个循环,条件是  栈是否空

在一棵树的遍历过程中,

递归有点像自上而下,自树根到叶子
我们非递归实现,有点像自下而上,从叶子到树根

在我们的栈中记录着的是一棵棵树根,我们要遍历它的左右子树
这确实有点像递归的逆过程
我们从最简单的地方开始,左右子树都是叶子
我们一直向左走,走到尽头,来到了最左的结点
既然是最左的结点,它的左子树必然是空的
根据

+ 是否有右子树/右子树是否为空
+ 是双亲的右孩子还是双亲的左孩子

这最左叶子有4种形态
这个最左的结点,
是current的根,
是当前要处理的树,
是问题的最简单形态
整个问题是一层层向上解决,也是一步步退栈进栈的过程

根据三种遍历的要求
(**先序和中序,比较简单一致,后序遍历难度最大**)

current 是当前的树的根

**当前树是上层树的左子树**

栈中是一层层的双亲/根

根据树根找到最左结点T
遍历树T:

+ 树T的左子树为空
+ 栈中是根
+ 根指向根的右子树
+ 处理这棵右子树
直到栈空


三种遍历

+ 先序:根左右
+ 中序:左根右
+ 后序: 左右根


##思路/算法很重要
这里的栈是我们实现算法用到的数据结构
在我们动手写程序之前,
脑海中有没有一个清晰被验证正确的算法呢,?

没有一个清晰的算法去验证过,
所以,在写的过程中,我发现自己写不下去了,思路陷入了循环之中

有的问题简单,以至于在一行行程序之中思路渐渐明晰然后被解决了
而困难的问题并不这样

我的思路:
我在纸上模拟了递归调用栈
可我并不能实现,从左子树退栈干这个,从右子树退栈干这个,,,,

有些问题是要我们根据给出的算法描述,用程序语言去实现
有些是只提出了问题,要先自己想出**算法/解决方案**



非递归遍历的要点:
一种思路:
```c++
p指向第一个访问的结点;
while(p)
{
	if(visit(p->data)==ERROR)
		return ERROR;
	将p赋值成p的后继:对应于不同的遍历不同的找后继的规律
}

```
目录

[TOC]

##树和二叉树

+ 二叉树的:
	- 存储结构,
	- 各种操作,
+ 树和森林与二叉树的转换关系


###树的定义和基本术语
树的结构定义是一个递归的定义

+ 根和子树
+ 嵌套集合
+ 广义表
+ 凹入表示法

基本术语

+ 结点
	- 结点的度
		+ 度为0:叶子/终端结点
		+ 度非0:分支结点/非终端结点
			- 内部结点:除根以外的分支结点
	- 树的度:树内各结点的度的最大值
	- 结点的孩子:结点的子树的根
		- 双亲,兄弟,子孙
	- 结点的层次:根为第一层
		+ 堂兄弟:双亲在同一层的结点
		+ 树的深度:结点的最大层次
+ 有序树,无序树
+ 森林
	- 森林和树的相互递归定义
		+ 可用于二叉树的转换中

###二叉树			
定义,两个要点

+ 每个结点至多只有两颗子树
+ 子树有左右之分,有序树

####**二叉树的性质**
一些有用的大前提:

+ 树结构每个结点只有一个双亲
	- 从下往上/从叶子到根看树,每个结点对应一个分支,根除外
		- 所以总分支数\\(B\\)和结点数\\(n\\)有这样的关系:\\(B=n-1\\)
	- 从上往下看,总分支数\\(B\\)和结点数\\(n\\)有这样的关系
		- \\(B=\sum\limits_{i=0}^{k} i*n_{i},k为树的度\\)
+ 二叉树中只有度\\(为0,为1,为2\\)的三种结点
	- 有结论:\\(n=n_{0}+n_{1}+n_{2}\\)
+ 链表存储的树中每一个非空链域对应一个分支


**二叉树的**几个重要性质

1. 第\\(i\\)层至多有\\(2^{i-1}\\)个结点
	+ 最多就是满二叉树的情形,每一层都是上一层的二倍,数目必然是2的幂
2. 深度为\\(k\\)的二叉树至多有\\(2^k-1\\)个结点	
3. 关于度为0,1,2的结点个数的结论,,,,,:\\(n_{0}=n_{2}+1\\)[推导过程](#conclusion1)
	+ 对于完全二叉树来说,度为1的结点最多只有一个(才能满足完全二叉树的条件),也就是要么没有要么一个,
		- 所以,对于完全二叉树:\\(n_{0}=n_{2}+1,n_{1}<=1\\)
4. 满二叉树:
	- 定义:深度为\\(k\\)且有\\(2^k-1\\)个结点
	- 必要条件/意味着
		- 结点的度数要么为0要么为2(不存在度为1的结点)
		- 每一层上的结点数都是最大结点数
	+ 完全二叉树:编号一一对应,,,,,
		- 性质:具有n个结点的完全二叉树的深度为,,,,,,,
5. 一颗n个结点的完全二叉树,结点按层序编号,对任意结点i,有关于i和n的结论,,,,,,,

####**二叉树的存储结构**	

+ 顺序存储结构
	- 将结点与完全二叉树对照,根据结点的编号i得出索引,存在一个数组之中
		+ 最坏的情形,树中不存在度为2的结点
+ 链式存储结构
	- 二叉链表
		+ 含有\\(n\\)个结点的二叉链表有\\(n+1\\)个空链域[推导过程](#_4)
	- 三叉链表

####**遍历二叉树**				

+ 先序遍历
+ 中序遍历
+ 后序遍历
+ 层序遍历

其他遍历的情形,,(?)严蔚敏书本P132top
递归与非递归

+ 三种递归遍历区别仅在于次序
+ 非递归遍历实现由很大不同

**建立一棵二叉树**
根据带空子树的先序序列建立一棵二叉树
这个过程也是递归描述的


####**线索二叉树**

遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列
非线性结构进行线性化操作,使每个结点有且仅有(除..外..)前驱和后继

+ 线索链表
	- 二叉链表加上了标志域
+ 线索
	- 指向前驱后继的指针
+ 线索二叉树
+ 线索化:对二叉树进行某种次序的遍历使其变为线索二叉树
	- 在遍历过程中修改空指针,指向前驱/后继(?,如何实现)
+ 双向线索链表,头结点


要解决的问题

+ 如何在线索树上遍历得到想要的序列?
	- 思路分析
		+ 一个前提:度为0或1的结点的链域的Tag才有可能是Thread(线索),度为2的结点的链域的Tag皆为Link(指针)
		+ 先解决如何找单个结点的后继/前驱,遍历过程就是从某结点(根/最左尽头)开始依次找它的后继/前驱
			- 对于Tag为Thread的结点,可以直接得到相应的前驱/后继
			- 对于Tag为Link的结点,
				+ 必有相应的子树:LTag为Link则有左子树,RTag为Link则有右子树
				+ 根据遍历的规律,可以知道后继/前驱的规律
					- 中序遍历
						+ 结点的后继为右子树中最左下的结点(算法6.5,P134)
						+ 结点的前驱为左子树中最右下的结点
					- 后序遍历,找后继分为3中情况(后序遍历总是不一样.....)
						+ 结点是整棵树的根,后继为空
						+ 结点时双亲的右孩子/(结点是双亲的左**孩子**并且双亲右子树为空),后继为双亲
						+ 结点为双亲左孩子且双亲右子树不为空,结点后继为右子树后序遍历第一个结点
	- 如何找结点的后继:**Tag为Thread可直接得到,Tag为Link则按上边的讨论求得**
		+ 中序线索树中找前驱/后继的规律(?)
		+ 后序线索树中找前驱/后继的规律(?)
	- 优势:以线索链表为存储结构进行遍历,:常数因子比较小(?)**不用递归不用栈**
+ 如何线索化
	- 前驱后继的信息只有在遍历过程中才能得到,,
		+ 附设一个指针指向刚刚访问的结点
			- 中序遍历二叉树线索化(算法6.7,6.6,P135)
	- 引入头结点,双向,顺后继,顺前驱

二叉树遍历->线索二叉树--->下次遍历变得更方便更好,更快,,(?)

###树和森林

####**树的存储结构**
根据操作选择适合的结构

+ 双亲表示法:每个结点(根除外)只有一个双亲
	- 一组连续空间存储,附设指示器指示双亲结点的位置,便于求结点的根/双亲,不便于求结点的孩子
+ 孩子表示法,多重链表
	- 结点同构/不同构表示
	- n个结点n个孩子链表,n个结点的指针组成一个线性表
	- 便于找孩子,不便于找双亲
+ 孩子兄弟表示法(**二叉树表示法**)
	- 两个链域分别指向第一个孩子结点,和下一个兄弟结点

####**森林和二叉树的转换(树和二叉树的转换)**

####**森林和树的遍历**

###树与等价问题
并操作,查操作,阿克曼函数
用到了树的双亲表示法
可用于求最小生成树

###哈夫曼树及其应用

+ 路径长度
+ 树的路径长度
+ 树的带权路径长度\\(WPL = \sum\limits_{k=1}^{n} w_{k}l_{k}\\)

编码问题与哈夫曼树性质的等价性

编码:从叶子出发走到根结点
解码:从根出发走到叶子结点
所以既要满足找根操作,又要满足找孩子操作

存储结构,算法实现

###回溯法和树的遍历
在遍历过程中建立的状态树(?)
###树的计数
\\(n个结点互不相似的二叉树的数目b_{n}\\)
数学解法,,,(?)
有遍历推得,,,,(?)
**由序列确定树的问题**
两个不相似的树可能有相同的遍历序列


######conclusion1

\\(n=n_{0}+n_{1}+n_{2}\\)
\\(B=n-1\\)
\\(B=2 * n_{2}+1 * n_{1}+0 * n_{0}\\)

由以上三式可得\\(n_{0}=n_{2}+1\\)
######二叉链表空链域结论
共有\\(2*n\\)个链域
非空链域对应分支数,有\\(n-1\\)个
空链域有\\(2 * n - (n-1) = n+1\\)个





###栈
####顺序栈
顺序栈的常态:top指向栈顶元素的下一个位置,也就是入栈的位置
####链栈
链栈的常态:top指向第一个结点,初始化时为空

插入,删除都只需要考虑第一个结点,***不需要头结点***

###队列
####链队列,队列的链式实现
需要两种结构体

链中元素是一种结点类型:LQueueNode:data+next
链队列需要时一种类型/结构体:LQueue:front+rear

为了使空队列和非空队列操作一致,***需要头结点***
初始化:front,rear这两个指针都指向一个next为空的头结点,这是一个***空队列***

enqueue:入队,是在尾部进行,

+ 新建一个结点,data赋值,***next赋空***,(链队列尾部的NULL,是这样来的)
+ 修改rear指向结点的next,
+ 修改rear,指向新建的结点

最重要的是,第一步,队列是如何建立起来的:空队列在尾部一个个入队
队列的常态:front指向头结点,rear指向尾结点

dequeue:出队,是在头部进行

+ 保存队列的第一个结点,:新建一个指针p,指向它
+ 修改头指针,使之指向这个结点的下一个结点
	- ***判断一下这个结点是不是最后一个结点(rear == p),***
		+ 如果是要修改尾指针,因为这个结点要被释放了,队列已为空
+ 释放结点: free(p)		

####循环队列,队列的顺序实现

还有一种是,front始终是位置0的实现,这样出队时要移动剩余的n-1个元素,,,,,,,

front,rear都是可变的实现:

+ 初始化:申请一个MAX_SIZE大小的数组,front,rear都赋值为0
+ 队列的常态:front指向第一个结点,rear指向最后一个结点的下一个结点,也就是入队的位置
+ 循环队列,循环使用,从0处开始
	- 出队后front加一
	- 入队后rear也加一
	- 加一后都要对MAX_SIZE取余
	- front,rear相对位置是不固定的
+ ***队列的长度;(rear - front + MAX_SIZE)%MAX_SIZE***

###栈的应用
####表达式求值/中缀转换为后缀/算符优先文法
规则

表达式的组成

+ 操作数operand
+ 操作符operator +,-,*,/
+ 界限符delimiter

+ 先乘除后加减
+ 同一级自作向右
	- 同一级运算符,左边大于右边
+ 先括号外后括号内
	- [+/-/*//]在左时低于(,高于)

算法思想
(三种操作)

+ `>` 读入操作符优先级低于栈顶运算符优先级时,**要运算**
+ `=` **脱括号**,;
	- **等号`=`当且仅当(读入是`(`栈顶是`)`时,才会出现**
	- 正是有了脱括号,
	转换成的后缀表达式才不需要括号
+ `<` 操作符**入栈**

+ 当读到`#`时,说明读到头了

**<u>这个算法既可以用来表达式求值,也可以用来中缀转后缀</u>**
做成的调整就是

+ 求值时,是把一次运算`a op b`的结果`c`写入操作数栈中
+ 转换为后缀时,把一次运算`a op b`写为后缀式`a b op`作为整体计入操作数栈中即可